import { existsSync, mkdirSync, readdirSync, readFileSync, writeFileSync } from "node:fs";
import { fileURLToPath } from "node:url";
import path from "node:path";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const webRoot = path.join(__dirname, "..");
const repoRoot = path.join(webRoot, "..");
const modulesWorkspace = path.join(repoRoot, "modules");
const outDir = path.join(webRoot, "lib", "generated");
const outPath = path.join(outDir, "optional-modules.generated.ts");

function normalizeRoutePath(value) {
  const raw = String(value || "").trim();
  if (!raw) return null;
  return raw.startsWith("/") ? raw : `/${raw}`;
}

function asString(value, fallback = "") {
  if (typeof value !== "string") return fallback;
  return value.trim() || fallback;
}

function normalizeNavLabels(value, fallbackLabel) {
  const base = {
    pl: fallbackLabel,
    en: fallbackLabel,
    de: fallbackLabel,
  };
  if (!value || typeof value !== "object") {
    return base;
  }
  const source = value;
  return {
    pl: asString(source.pl, fallbackLabel),
    en: asString(source.en, fallbackLabel),
    de: asString(source.de, fallbackLabel),
  };
}

function toConstName(moduleId) {
  const base = String(moduleId || "module").replace(/[^a-zA-Z0-9]/g, "_");
  const normalized = base.replace(/^[0-9]/, "_$&");
  return `ModuleEntry_${normalized}`;
}

function loadManifest(manifestPath) {
  try {
    const parsed = JSON.parse(readFileSync(manifestPath, "utf-8"));
    return {
      schemaVersion: Number(parsed.schema_version || 1),
      moduleId: asString(parsed.module_id),
      displayName: asString(parsed.display_name, "Optional Module"),
      frontend: parsed.frontend || {},
    };
  } catch {
    return null;
  }
}

function collectManifestPaths() {
  const result = [];

  if (existsSync(modulesWorkspace)) {
    for (const item of readdirSync(modulesWorkspace, { withFileTypes: true })) {
      if (!item.isDirectory()) continue;
      const manifestPath = path.join(modulesWorkspace, item.name, "module.json");
      if (existsSync(manifestPath)) {
        result.push(manifestPath);
      }
    }
  }

  return result;
}

function buildEntries() {
  const seen = new Set();
  const entries = [];
  for (const manifestPath of collectManifestPaths()) {
    const loaded = loadManifest(manifestPath);
    if (!loaded || !loaded.moduleId) continue;
    if (seen.has(loaded.moduleId)) continue;
    seen.add(loaded.moduleId);

    const routePath = normalizeRoutePath(loaded.frontend?.nav_path);
    if (!routePath) continue;

    entries.push({
      schemaVersion: loaded.schemaVersion,
      moduleId: loaded.moduleId,
      displayName: loaded.displayName,
      routePath,
      featureFlagEnv: asString(loaded.frontend?.feature_flag) || null,
      navLabel: asString(loaded.frontend?.nav_label, loaded.displayName),
      navLabels: normalizeNavLabels(
        loaded.frontend?.nav_labels,
        asString(loaded.frontend?.nav_label, loaded.displayName),
      ),
      componentImport: asString(loaded.frontend?.component_import) || null,
    });
  }
  return entries.sort((a, b) => a.moduleId.localeCompare(b.moduleId));
}

function renderFile(entries) {
  const importLines = [
    'import type { ComponentType } from "react";',
    'import type { LucideIcon } from "lucide-react";',
    'import { Settings } from "lucide-react";',
  ];

  const mappedEntries = entries.map((entry) => {
    const constName = toConstName(entry.moduleId);
    if (entry.componentImport) {
      importLines.push(`import ${constName} from "${entry.componentImport}";`);
    }
    return { ...entry, constName };
  });

  const listBody = mappedEntries
    .map((entry) => {
      const featureFlag = entry.featureFlagEnv ? `"${entry.featureFlagEnv}"` : "null";
      return `  {
    schemaVersion: ${entry.schemaVersion},
    moduleId: "${entry.moduleId}",
    displayName: "${entry.displayName.replace(/"/g, '\\"')}",
    routePath: "${entry.routePath}",
    featureFlagEnv: ${featureFlag},
    navLabel: "${entry.navLabel.replace(/"/g, '\\"')}",
    navLabels: {
      pl: "${entry.navLabels.pl.replace(/"/g, '\\"')}",
      en: "${entry.navLabels.en.replace(/"/g, '\\"')}",
      de: "${entry.navLabels.de.replace(/"/g, '\\"')}",
    },
  }`;
    })
    .join(",\n");

  const componentMapBody = mappedEntries
    .map((entry) => {
      if (!entry.componentImport) return `  "${entry.moduleId}": null`;
      return `  "${entry.moduleId}": ${entry.constName}`;
    })
    .join(",\n");

  const distinctFlags = Array.from(
    new Set(
      mappedEntries
        .map((entry) => entry.featureFlagEnv)
        .filter((flag) => typeof flag === "string" && flag.length > 0),
    ),
  );

  const envValueMapBody = distinctFlags
    .map((flag) => `  "${flag}": process.env.${flag} ?? ""`)
    .join(",\n");

  return `// AUTO-GENERATED by scripts/generate-optional-modules.mjs. Do not edit manually.

${importLines.join("\n")}

export type OptionalModuleManifest = {
  schemaVersion: number;
  moduleId: string;
  displayName: string;
  routePath: string;
  featureFlagEnv: string | null;
  navLabel: string;
  navLabels: {
    pl: string;
    en: string;
    de: string;
  };
};

export type OptionalModuleNavItem = {
  href: string;
  label: string;
  labels: {
    pl: string;
    en: string;
    de: string;
  };
  icon: LucideIcon;
  featureFlagEnv?: string;
};

const OPTIONAL_MODULES: OptionalModuleManifest[] = [
${listBody}
];

const OPTIONAL_MODULE_COMPONENTS: Record<string, ComponentType | null> = {
${componentMapBody}
};

const OPTIONAL_MODULE_ENV_VALUES: Record<string, string> = {
${envValueMapBody}
};

function isEnvFlagEnabled(flagName: string): boolean {
  const raw = OPTIONAL_MODULE_ENV_VALUES[flagName] ?? "";
  if (!raw) {
    return false;
  }
  const normalized = raw.trim().toLowerCase();
  return normalized === "1" || normalized === "true" || normalized === "yes" || normalized === "on";
}

export function getOptionalModuleManifests(): OptionalModuleManifest[] {
  return OPTIONAL_MODULES.slice();
}

export function getEnabledOptionalModuleNavItems(): OptionalModuleNavItem[] {
  return OPTIONAL_MODULES.filter((moduleItem) => {
    if (!moduleItem.featureFlagEnv) {
      return true;
    }
    return isEnvFlagEnabled(moduleItem.featureFlagEnv);
  }).map((moduleItem) => ({
    href: moduleItem.routePath,
    label: moduleItem.navLabel,
    labels: moduleItem.navLabels,
    icon: Settings,
    featureFlagEnv: moduleItem.featureFlagEnv ?? undefined,
  }));
}

export function resolveOptionalModuleBySlug(slug: string): OptionalModuleManifest | null {
  const target = "/" + String(slug || "").replace(/^\\/+/, "");
  for (const item of OPTIONAL_MODULES) {
    if (item.routePath === target) {
      return item;
    }
  }
  return null;
}

export function getOptionalModuleComponent(moduleId: string): ComponentType | null {
  return OPTIONAL_MODULE_COMPONENTS[moduleId] ?? null;
}
`;
}

function main() {
  const entries = buildEntries();
  mkdirSync(outDir, { recursive: true });
  writeFileSync(outPath, renderFile(entries));
  console.log(`[modules] Wrote ${outPath} -> ${entries.length} module(s)`);
}

main();
