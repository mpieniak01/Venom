
# VENOM – MASTER VISION v2 (ONNX Edition)
## Meta-inteligencja lokalna. Jeden runtime. Jeden organizm.

## 0. Wprowadzenie – czym jest Venom?
Venom to projekt stworzenia organizmu sztucznej inteligencji, który rozwija, nadzoruje i projektuje inne systemy AI.
To warstwa meta-inteligencji działająca nad Rider-PC (logika, kod, AI) oraz Rider-Pi (świat fizyczny, sensory, ruch).
Venom może w przyszłości objąć każdym innym modułem Twojego ekosystemu.

Venom to inteligentny, adaptacyjny, uczący się organizm, który:
- rozumie intencje użytkownika,
- buduje plany techniczne i architektury systemów,
- orkiestruje sieć agentów,
- pisze, modyfikuje i testuje kod,
- posiada pamięć długoterminową,
- rozszerza wiedzę przez internet i modele eksperckie,
- uczy się z każdego zadania,
- działa w pełni local-first,
- respektuje polityki i user-ethics.

Venom traktuje:
- Rider-Pi jako swoje ciało,
- Rider-PC jako swoje środowisko wewnętrzne,
- modele ONNX + narzędzia jako organy,
- agentów jako wyspecjalizowane tkanki.

Venom to meta-mózg, organizm sztucznej inteligencji, architekt kodu, orkiestrator agentów, menedżer wiedzy, strażnik zasad oraz AI, która tworzy AI.

## 1. Definicja techniczna – czym jest Venom jako system
Venom to warstwa meta-inteligencji lokalnej, która przyjmuje intencję użytkownika i przekształca ją w działające rozwiązanie poprzez:
- analizę kontekstu projektu,
- budowanie planów wykonania,
- sterowanie agentami,
- generowanie i refaktoring kodu,
- testowanie i integrację,
- zarządzanie wiedzą lokalną i zewnętrzną,
- mechanizmy samodoskonalenia.

Venom działa w oparciu o jeden standard modeli lokalnych: **ONNX Runtime**.
Oracle Models (chmurowe) są opcjonalne i działają tylko w wybranych politykach.

## 2. Model biologiczny Venoma – organizm sztucznej inteligencji
<table>
<tr><th>Organ</th><th>Funkcja</th><th>Technologia</th><th>Rola w organizmie</th></tr>
<tr><td>System nerwowy</td><td>Orkiestracja</td><td>AutoGen</td><td>Dialog, pętle decyzyjne</td></tr>
<tr><td>Płat czołowy</td><td>Szybkie myślenie</td><td>Phi-3 ONNX</td><td>Generuje 90% kodu</td></tr>
<tr><td>Wyrocznia</td><td>Głębokie myślenie</td><td>GPT-4o, Gemini Pro, Claude</td><td>Trudne problemy</td></tr>
<tr><td>Antena</td><td>Zmysł zewnętrzny</td><td>Web-Agent</td><td>Wiedza z internetu</td></tr>
<tr><td>Hipokamp</td><td>Pamięć</td><td>GraphRAG</td><td>Mapa wiedzy</td></tr>
<tr><td>Ręce</td><td>Działanie</td><td>Semantic Kernel</td><td>Pliki, shell, git</td></tr>
<tr><td>Oczy (cyfrowe)</td><td>Percepcja UI</td><td>Florence-2 ONNX</td><td>OCR, analiza UI</td></tr>
<tr><td>Oczy (fizyczne)</td><td>Percepcja w świecie</td><td>YOLO ONNX</td><td>Obiekty, przeszkody</td></tr>
<tr><td>Nogi</td><td>Ruch</td><td>Rider-Pi</td><td>Mobilność</td></tr>
<tr><td>Metabolizm</td><td>Wydajność</td><td>ONNX Runtime</td><td>Wykonanie modeli</td></tr>
<tr><td>Habitat</td><td>Środowisko</td><td>WSL2 + Dev Containers</td><td>Sandbox</td></tr>
</table>

## 2A. Warstwa modeli – jeden standard: ONNX Runtime
Venom używa jednego standardu modeli lokalnych – **ONNX Runtime**.

### Kategorie modeli:
1. **Worker Models (robotnicy)** – szybkie modele ONNX.
2. **Architect Models (architekci)** – duże modele ONNX, jeśli sprzęt pozwala.
3. **Oracle Models (zewnętrzne)** – gdy potrzebna wiedza ekspercka.

## 3. Warstwy Venoma (Architektura systemu)

### 3.1. Warstwa meta (Core Meta Layer)
- Orchestrator
- Intent Manager
- Policy Engine
- Task Log / State

### 3.2. Warstwa pamięci (Memory Layer)
GraphRAG – struktura repo, zależności, wiedza projektowa.

### 3.3. Warstwa agentów (Agent Services Layer)
- planner.arch
- planner.repo
- code.autogen
- code.style
- test.pytest
- test.smoke
- git.integrator
- docs.writer

### 3.4. Warstwa wykonawcza (Execution Layer)
Semantic Kernel – pliki, shell, git, testy.

### 3.5. Warstwa percepcji (Vision Layer)
- Florence-2 ONNX – UI vision
- YOLO ONNX – physical vision

### 3.6. Warstwa metabolizmu (Performance Layer)
ONNX Runtime – wykonanie modeli, optymalizacja GPU/CPU.

## 4. Warstwa wiedzy zewnętrznej (External Knowledge Layer)
Trzy źródła:
1. Wiedza lokalna – GraphRAG.
2. Wiedza ekspercka lokalna – duże modele ONNX.
3. Wiedza zewnętrzna – Web-Agent + Oracle.

Zasady:
- local-first,
- internet tylko świadomie i logowany,
- źródła oznaczone i wersjonowane.

## 5. Warstwa samodoskonalenia (Self-Improvement Layer)
Venom uczy się poprzez:
- wyniki testów,
- PR-y,
- logi,
- błędy,
- retry loops,
- analizę wiedzy zewnętrznej.

Ulepsza:
- heurystyki,
- workflowy,
- style kodowania,
- strategie agentów,
- polityki.

## 6. Pipeline Venoma
1. Intencja użytkownika
2. Orchestrator
3. GraphRAG
4. (opcjonalnie) Oracle/Web
5. planner.arch
6. planner.repo
7. AutoGen + ONNX
8. Phi-3 ONNX
9. Semantic Kernel
10. Testy
11. Git integrator
12. GraphRAG update
13. Self-Improvement update

## 7. Polityki Venoma
- polityka wiedzy
- polityka repo
- polityka autonomii
- user ethics
- polityki testów
- bezpieczeństwo

## 8. Integracja z Rider-PC i Rider-Pi
Rider-PC – centrum logiczne.
Rider-Pi – ciało fizyczne.

Venom koordynuje cały ekosystem.

## 9. Finalna definicja
Venom to:
- meta-mózg,
- organizm AI,
- architekt systemów,
- orkiestrator agentów,
- menedżer wiedzy,
- system uczący się,
- strażnik zasad,
- AI tworząca AI.

I wszystkie modele działają w jednym standardzie: **ONNX Runtime**.
