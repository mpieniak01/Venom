#!/usr/bin/env python3
"""Local pre-check for Sonar-like coverage on changed Python lines.

The script reads:
- Cobertura XML generated by pytest-cov (`python-coverage.xml`)
- changed lines from git diff (`origin/main...HEAD` by default)
- optional Sonar coverage exclusions from `sonar-project.properties`

It reports coverage for coverable changed lines and exits non-zero if the
configured minimum is not met.
"""

from __future__ import annotations

import argparse
import fnmatch
import re
import subprocess
import sys
import xml.etree.ElementTree as ET
from dataclasses import dataclass
from pathlib import Path


@dataclass
class FileCoverage:
    path: str
    covered: int
    total: int

    @property
    def rate(self) -> float:
        return (self.covered / self.total) if self.total else 0.0


def _run_git_diff(diff_base: str, scope: str) -> str:
    cmd = ["git", "diff", "-U0", f"{diff_base}...HEAD", "--", scope]
    proc = subprocess.run(cmd, capture_output=True, text=True, check=False)
    if proc.returncode != 0:
        raise RuntimeError(
            f"git diff failed for base '{diff_base}'. stderr:\n{proc.stderr.strip()}"
        )
    return proc.stdout


def _parse_changed_lines(diff_text: str) -> dict[str, set[int]]:
    changed: dict[str, set[int]] = {}
    current_file: str | None = None
    hunk_re = re.compile(r"@@ -\d+(?:,\d+)? \+(\d+)(?:,(\d+))? @@")

    for line in diff_text.splitlines():
        if line.startswith("+++ b/"):
            current_file = line[6:]
            continue
        if not line.startswith("@@") or not current_file:
            continue
        match = hunk_re.search(line)
        if not match:
            continue
        start = int(match.group(1))
        count = int(match.group(2) or "1")
        if count == 0:
            continue
        target = changed.setdefault(current_file, set())
        for number in range(start, start + count):
            target.add(number)
    return changed


def _parse_sonar_coverage_exclusions(config_path: Path) -> list[str]:
    if not config_path.exists():
        return []

    lines = config_path.read_text(encoding="utf-8").splitlines()
    for index, line in enumerate(lines):
        if not line.startswith("sonar.coverage.exclusions="):
            continue
        value = line.split("=", 1)[1]
        cursor = index
        while value.rstrip().endswith("\\") and cursor + 1 < len(lines):
            value = value.rstrip()[:-1] + lines[cursor + 1].strip()
            cursor += 1
        return [item.strip() for item in value.split(",") if item.strip()]
    return []


def _is_excluded(path: str, patterns: list[str]) -> bool:
    return any(fnmatch.fnmatch(path, pattern) for pattern in patterns)


def _load_coverage_hits(xml_path: Path) -> dict[str, dict[int, int]]:
    if not xml_path.exists():
        raise FileNotFoundError(f"Coverage XML not found: {xml_path}")

    tree = ET.parse(xml_path)
    root = tree.getroot()
    hits: dict[str, dict[int, int]] = {}
    for cls in root.findall(".//class"):
        filename = cls.attrib.get("filename", "")
        if not filename:
            continue
        normalized = (
            filename if filename.startswith("venom_core/") else f"venom_core/{filename}"
        )
        line_hits: dict[int, int] = {}
        for line in cls.findall("./lines/line"):
            line_no = int(line.attrib["number"])
            line_hits[line_no] = int(line.attrib.get("hits", "0"))
        hits[normalized] = line_hits
    return hits


def _calculate(
    changed_lines: dict[str, set[int]],
    coverage_hits: dict[str, dict[int, int]],
    exclusions: list[str],
) -> tuple[list[FileCoverage], int, int]:
    per_file: list[FileCoverage] = []
    total_coverable = 0
    total_covered = 0

    for path, lines in sorted(changed_lines.items()):
        if not path.startswith("venom_core/"):
            continue
        if _is_excluded(path, exclusions):
            continue
        file_hits = coverage_hits.get(path, {})
        coverable_lines = [line for line in sorted(lines) if line in file_hits]
        if not coverable_lines:
            continue
        covered = sum(1 for line in coverable_lines if file_hits.get(line, 0) > 0)
        total = len(coverable_lines)
        total_coverable += total
        total_covered += covered
        per_file.append(FileCoverage(path=path, covered=covered, total=total))

    return per_file, total_covered, total_coverable


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Check coverage for changed lines (Sonar pre-check)."
    )
    parser.add_argument(
        "--coverage-xml",
        default="test-results/sonar/python-coverage.xml",
        help="Path to Cobertura XML report.",
    )
    parser.add_argument(
        "--sonar-config",
        default="sonar-project.properties",
        help="Path to Sonar config (for coverage exclusions).",
    )
    parser.add_argument(
        "--diff-base",
        default="origin/main",
        help="Base branch/ref used in git diff (default: origin/main).",
    )
    parser.add_argument(
        "--scope",
        default="venom_core",
        help="Path scope for diff (default: venom_core).",
    )
    parser.add_argument(
        "--min-coverage",
        type=float,
        default=70.0,
        help="Required minimum coverage %% on changed coverable lines.",
    )
    parser.add_argument(
        "--show-top",
        type=int,
        default=15,
        help="Number of lowest-coverage files to display.",
    )
    args = parser.parse_args()

    diff_text = _run_git_diff(diff_base=args.diff_base, scope=args.scope)
    changed_lines = _parse_changed_lines(diff_text)
    exclusions = _parse_sonar_coverage_exclusions(Path(args.sonar_config))
    coverage_hits = _load_coverage_hits(Path(args.coverage_xml))

    per_file, total_covered, total_coverable = _calculate(
        changed_lines, coverage_hits, exclusions
    )

    if total_coverable == 0:
        print("No coverable changed lines found (after exclusions).")
        return 0

    rate = (total_covered / total_coverable) * 100.0
    print(
        f"Changed lines coverage: {total_covered}/{total_coverable} = {rate:.1f}% "
        f"(required: {args.min_coverage:.1f}%)"
    )

    print("\nLowest coverage files (changed + included):")
    for item in sorted(per_file, key=lambda row: row.rate)[: max(args.show_top, 1)]:
        print(f"- {item.path}: {item.covered}/{item.total} ({item.rate * 100:.1f}%)")

    if rate + 1e-9 < args.min_coverage:
        print("\nFAIL: changed-lines coverage is below required threshold.")
        return 1

    print("\nPASS: changed-lines coverage meets the threshold.")
    return 0


if __name__ == "__main__":
    sys.exit(main())
